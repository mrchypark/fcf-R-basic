#                                    #
#       패스트 캠퍼스 온라인         #
#   금융 공학 / 퀀트 올인원 패키지   #
#    R 프로그래밍 - 강사. 박찬엽     #
#                                    #

# 데이터의 기본  ----
## 8. 단일 종류의 데이터 ----

## 벡터의 생성
a <- c(1,2,3)

## 벡터값 확인
a

## 벡터의 정보 확인
str(a)

## 벡터의 길이 출력
lneght(a)

## 8.1 논리형 벡터  ----
lgl_v <- c(T, F, TRUE, FALSE)
lgl_v

typeof(lgl_v)

## 8.2 숫자형 벡터 ----
# double 은 실수형 이라는 뜻이다. 
typeof(1)

# integer는 정수형이라는 뜻이다.
typeof(1L)

num_v <- c(10, -100, 0.6, 0.333)
num_v
typeof(num_v)

## nan은 Not a Number 의 약자로 표현이 불가능한 연산에 대한 답으로 사용한다.
## sqrt() 함수는 루트 연산을 수행한다.
sqrt(-4)

## na는 Not Available 의 약자로 결측된 값, 혹은 사용할 수 없음을 뜻한다.
c(10/0, 0/0, NA)

0/0 == NaN
is.nan(0/0)
is.na(0/0)

## 8.3 글자형 벡터 ----

# 글자형은 따옴표(')나 쌍따옴표(")로 감싸서 표현한다.
chr_v <- c("글자형","a","T","1")
typeof(chr_v)

"따옴표를 글자로 인식하려면 ' 쌍따옴표로 감싼다."
'쌍따옴표를 글자로 인식하려면 " 따옴표로 감싼다.'

"같은 것으로 처리하고 싶을 때는 \" 같이 표시한다."



## 9 단일 종류의 데이터 다루기 ----
## 9.1 강제로 다른 종류의 데이터로 바꾸기 ----
# 강제형변환 이라는 용어를 사용함
# 논리형 -> 숫자형 -> 글자형 방향으로 바꿔준다.
tem <- c(1, T, F, TRUE)
tem
typeof(tem)

tem <- c("글자", 1, -1)
tem
typeof(tem)

tem <- c("글자", T, FALSE)
tem
typeof(tem)

## 9.2 강제로 데이터의 길이를 맞추기 ----
# 스칼라란 1개의 데이터를 뜻함
# 벡터는 스칼라를 포함함
# 데이터가 여러 개인 데이터와 하나의 데이터를 연산하면?
1:10
1:10 + 10

# 데이터의 길이가 다른 데이터들을 연산하면?
# 재활용 규칙이라고 함
1:10 + 1:5

1:10 + 1:3

## 9.3 벡터내의 데이터에 이름을 지정하기 ----
# key-value 라고 부르며 여기서 key가 이름, value가 데이터를 뜻함
# R에서 모든 벡터는 key-value로 데이터의 이름을 지정할 수 있음
# key = value 의 형식을 따르며 key는 이름이기 때문에 따옴표를 생략할 수 있음
# 이름은 데이터의 일부를 사용하고 싶을 때 유용함

c("a" = "k")
c(a = "k", b = "kk", c = "kkk")


## 9.4 데이터의 일부를 사용하기 ----
# 서브셋(subset) 이라고 부르며 가지고 있는 데이터에서 일부만을 사용할 때의 문법을 뜻함.
# 벡터는 벡터[] 의 형태로 뒤에 대괄호를 붙이며 대괄호 안에 벡터를 넣어서 일부의 데이터만 사용한다.
subs <- c("하나", "둘", "셋", "넷", "다섯")

## 9.4.1 논리형 벡터로 데이터의 일부를 사용하기 ----
# 데이터의 갯수에 맞게 논리형 데이터를 넣어야 하며, 부족하게 입력하면 재활용 규칙이, 많이 입력하면 NA를 붙여서 결과를 줌
subs[c(T,F,T,F,T)]

subs[c(T,F)]

subs[c(T,F,T,F,T,T,T)]

## 9.4.2 숫자형 벡터로 데이터의 일부를 사용하기 ----
# 특별히 인덱싱(indexing)이라고 하며 데이터의 위치를 순서대로 1, 2, 3 ... 이라고 지정하기 때문에 필요한 위치를 숫자로 지정하여 일부를 선택할 수 있음

subs[c(1,2,3)]

# 숫자형으로 하면 위치를 지정할 수도, 계속 같은걸 더 사용할 수도 있음
subs[c(3,2,1)]

subs[c(1,1,1,1,1)]

# 음수로 작성하면 그 위치의 데이터를 제외한 나머지를 사용함
subs[c(-1,-2)]

# 대신 양수, 음수를 동시에 사용할 수 없음
subs[c(-1,1)]

# 원래 데이터 범위를 벗어나면 NA를 사용함
subs[c(6)]


## 9.4.3 글자형 벡터로 데이터의 일부를 사용하기 ----
# 글자형 벡터로 일부를 사용하기 위해서는 데이터에 이름을 지정해 두어야 함.

subs_name <- c(a = "하나", b = "둘", c = "셋", d = "넷", e = "다섯")

# 앞서 숫자형 벡터와 같이 동작함.
subs_name[c("a","c","f", "a")]

# 특별히 벡터[[]] 로 이중 대괄호라는 방법이 있음
# 하나의 데이터만 호출할 수 있고, 이름은 빼고 사용함

subs_name[["a"]]
subs_name[[c("a","b")]]
subs_name[[1]]
subs_name[[1]]


## 10 리스트 다루기 ----
## 10.1 리스트 자료형이란 ----
# 다양한 종류의 데이터를 가지는 데이터 묶음
# 심지어 리스트 자료형도 데이터로 가질 수 있음
# 그래서 재귀형(recursive)이라고 하기도 함

mul_l <- list(1, 2, 3)
mul_l

# ?str을 실행해서 도움말을 확인해보세요!
str(mul_l)

# 리스트 역시 벡터이므로 데이터에 이름을 지정할 수 있음
mul_ln <- list(a = 1,b = 2,c = 3)
mul_ln
str(mul_ln)

# 리스트는 여러 다양한 자료형을 가질 수 있음
mul_ll <- list("a", 1L, 1.5, T, list(1,2))
mul_ll
str(mul_ll)

## 10.2 리스트 자료형의 데이터 일부 사용하기 ----
# 벡터와 문법이 같다.
# 특별히 대괄호와 이중 대괄호의 동작 차이가 중요함
# 대괄호의 결과는 항상 리스트
mul_ll[c(1,2)]
str(mul_ll[c(1,2)])

mul_ll[5]
str(mul_ll[5])

# 이중 대괄호는 리스트의 한단계를 없앤 결과를 줌
mul_ll[[1]]
str(mul_ll[[1]])

mul_ll[[c(1,2)]]

mul_ll[[5]]
str(mul_ll[[5]])

# 리스트의 데이터에 이름이 달려 있다면 이중 대괄호와 같은 의미인 $를 사용할 수 있음
mul_ln <- list(a = 1,b = 2,c = 3, d = list(3,4))
mul_ln[[3]]
mul_ln[["c"]]
mul_ln$c

# 리스트에 리스트가 가능하므로 이중 대괄호의 대괄호, 이중 대괄호의 이중 대괄호 등이 가능함
mul_ln[["d"]][1]
mul_ln[["d"]][[1]]

